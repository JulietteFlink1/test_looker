view: address_daily_aggregates {
  sql_table_name: `flink-data-prod.curated.address_daily_aggregates`
    ;;

  dimension: has_order {
    type: yesno
    sql: ${TABLE}.has_order ;;
  }

  dimension: platform {
    type: string
    sql: ${TABLE}.platform ;;
  }

  ## I want to additional fields: one is the hub that appOpened detected, one is a flag that says whether appOpened changed the hub assignment since the last other event happened

  measure: count {
    description: "Counts the number of occurrences of the selected dimension(s)"
    type: count
    drill_fields: [detail*]
  }

  ######### IDs ##########
  dimension: anonymous_id {
    group_label: "IDs"
    description: "Anonymous ID generated by Segment as user identifier"
    type: string
    sql: ${TABLE}.anonymous_id ;;
  }

  dimension: session_id {
    group_label: "IDs"
    description: "Session ID based on user and session definition, primary key of this model"
    type: string
    primary_key: yes
    sql: ${TABLE}.session_uuid ;;
  }

  dimension: timezone {
    type: string
    sql: ${TABLE}.timezone ;;
  }

  dimension: user_id {
    group_label: "IDs"
    description: "Internal user ID, generated when user creates an account with us"
    type: string
    sql: ${TABLE}.user_id ;;
  }

  ########## Device attributes #########
  dimension: app_version {
    group_label: "Device Dimensions"
    label: "App version"
    description: "App version used in the session"
    type: string
    sql: ${TABLE}.app_version ;;
  }

  dimension: device_type {
    group_label: "Device Dimensions"
    label: "Device Type"
    description: "iOS or Android"
    type: string
    sql: ${TABLE}.device_type ;;
  }

  dimension: full_app_version {
    group_label: "Device Dimensions"
    description: "Device type and app version combined in one dimension"
    type: string
    sql: ${device_type} || '-' || ${app_version} ;;
  }

  ########## Location attributes #########
  dimension: hub_code {
    group_label: "Location Dimensions"
    description: "Hub code associated with the last address the user selected"
    type: string
    sql: ${TABLE}.hub_code ;;
  }

  dimension: hub_city {
    group_label: "Location Dimensions"
    label: "City"
    description: "City associated with the last address the user selected"
    type: string
    sql: ${TABLE}.city ;;
  }

  dimension: country_iso {
    hidden: yes
    type: string
    sql: ${TABLE}.country_iso ;;
  }

  dimension: country {
    group_label: "Location Dimensions"
    description: "Country ISO associated with the last address the user selected"
    type: string
    case: {
      when: {
        sql: ${country_iso} = "DE" ;;
        label: "Germany"
      }
      when: {
        sql: ${country_iso} = "FR" ;;
        label: "France"
      }
      when: {
        sql: ${country_iso} = "NL" ;;
        label: "Netherlands"
      }
      when: {
        sql: ${country_iso} = "AT" ;;
        label: "Austria"
      }
      else: "Other / Unknown"
    }
  }

  ######## # Sessions ########
  ##### Unique count of events during a session. If multiple events are triggerred during a session, e.g 3 times view item, the event is only counted once.

  measure: cnt_session_with_address {
    group_label: "# Sessions"
    label: "# Sessions With Address"
    description: "# sessions in which the user had an address (selected in previous session or current)"
    type: count
    filters: [is_session_with_address: "yes"]
  }

  measure: cnt_address_selected {
    group_label: "# Sessions"
    label: "# Sessions With Address Confirmed"
    description: "# sessions in which at least one Address Confirmed event happened"
    type: count
    filters: [cnte_address_confirmed: ">0"]
  }

  measure: cnt_location_pin_placed {
    group_label: "# Sessions"
    label: "# Sessions With Location Pin Placed"
    description: "# sessions in which at least one Location Pin Placed event happened"
    type: count
    filters: [cnte_location_pin_placed: ">0"]
  }

# for unknown reasons didn't work to count NOT NULL on waitlist_signup_selected, that's why created boolean and counting those
  dimension: has_waitlist_signup_selected {
    group_label: "Session Dimensions"
    description: "Whether there was a waitlist signup selected event in the session"
    type: yesno
    sql: ${cnte_waitlist_signup_selected} >0;;
  }

  measure: cnt_has_waitlist_signup_selected {
    group_label: "# Sessions"
    label: "# Sessions With Waitlist Intent"
    description: "# sessions in which Waitlist Signup Selected happened"
    type: count
    filters: [cnte_waitlist_signup_selected: ">0"]
  }

  measure: cnt_available_area {
    group_label: "# Sessions"
    label: "# Sessions At Deliverable Location"
    description: "# sessions in which the last Location Pin Placed event was at a location we can deliver to (=inside delivery zone and resolvable address)"
    type: count
    filters: [last_is_location_deliverable: "true", cnte_location_pin_placed: ">0"]
  }

  measure: cnt_unavailable_area {
    group_label: "# Sessions"
    label: "# Sessions Outside Deliverable Locations"
    description: "# sessions in which the last Location Pin Placed event was at a location we cannot deliver to (=outside delivery zone or no resolvable address)"
    type: count
    filters: [last_is_location_deliverable: "false", cnte_location_pin_placed: ">0"]
  }

  measure: cnt_address_skipped_in_available_area {
    group_label: "# Sessions"
    label: "# Sessions With Address Skipped, At Deliverable Location"
    description: "# sessions in which address selection was skipped at least once and the user was at a deliverable location and did not select any address"
    type: count
    filters: [last_is_location_deliverable: "true", cnte_address_skipped: ">0", cnte_address_confirmed: "0"]
  }

  measure: cnt_address_confirmed_area_available {
    group_label: "# Sessions"
    label: "# Sessions With Address Confirmed, Inside Delivery Area"
    description: "# sessions in which at least one address was selected and the user was in an available area"
    type: count
    filters: [last_is_location_deliverable: "true", cnte_address_confirmed: ">0", cnte_address_skipped: "0"]
  }

  measure: cnt_confirmed_and_skipped_area_available {
    group_label: "# Sessions"
    label: "# Sessions With Address Confirmed AND Address Skipped, Inside Delivery Area"
    description: "# sessions in which user was in an available area and both selected and skipped address at least once"
    type: count
    filters: [last_is_location_deliverable: "true", cnte_address_confirmed: ">0", cnte_address_skipped: ">0"]
  }

  measure: cnt_noaction_area_available {
    group_label: "# Sessions"
    label: "# Sessions Without Address Confirmed or Address Skipped but Location Pin Placed, Inside Delivery Area"
    description: "# sessions in which the user was in an available area but did not perform any address selection or skipping action"
    type: count
    filters: [last_is_location_deliverable: "true", cnte_address_confirmed: "0", cnte_address_skipped: "0", cnte_location_pin_placed: ">0"]
  }

  measure: cnt_waitlist_area_unavailable {
    group_label: "# Sessions"
    label: " # Sessions With Waitlist Intent, Outside Delivery Area"
    description: "# sessions in which the user was in an unavailable area and selected join waitlist"
    type: count
    filters: [last_is_location_deliverable: "false", cnte_waitlist_signup_selected: ">0", cnte_selection_browse_selected: "0"]
  }

  measure: cnt_browse_area_unavailable {
    group_label: "# Sessions"
    label: "# Sessions With Product Browsing, Outside Delivery Area"
    description: "# sessions in which the user was in an unavailable area and selected browse products"
    type: count
    filters: [last_is_location_deliverable: "false", cnte_selection_browse_selected: ">0", cnte_waitlist_signup_selected: "0"]
  }

  measure: cnt_waitlist_and_browse_area_unavailable {
    group_label: "# Sessions"
    label: "# Sessions With Waitlist Intent AND Product Browsing, Outside Delivery Area"
    description: "# sessions in which the user was in an unavailable area and selected join waitlist and selected browse products"
    type: count
    filters: [last_is_location_deliverable: "false", cnte_selection_browse_selected: ">0", cnte_waitlist_signup_selected: ">0"]
  }

  measure: cnt_noaction_area_unavailable {
    group_label: "# Sessions"
    label: "# Sessions Without Waitlist Intent or Product Browsing but Location Pin Placed, Outside Delivery Area"
    description: "# sessions in which the user was in an unavailable area and did not have a waitlist joining intent or browsing selection action"
    type: count
    filters: [last_is_location_deliverable: "false", cnte_waitlist_signup_selected: "0", cnte_selection_browse_selected: "0", cnte_location_pin_placed: ">0"]
  }

  # NOTE: want to update this to also be able to specify whether it's failed within delivery area or not
  measure: cnt_address_resolution_failed_inside_area {
    group_label: "# Sessions"
    label: "# Sessions With Address Unidentified, Inside Delivery Area"
    description: "# sessions in which there was at least one unidentified address inside delivery area"
    type: count
    filters: [cnte_address_resolution_failed_inside_area: ">0"]
  }

  measure: cnt_address_resolution_failed_outside_area {
    group_label: "# Sessions"
    label: "# Sessions With Address Unidentified, Outside Delivery Area"
    description: "# sessions in which there was at least one unidentified address outside delivery area"
    type: count
    filters: [cnte_address_resolution_failed_outside_area: ">0"]
  }

  measure: cnt_address_skipped {
    group_label: "# Sessions"
    label: "# Sessions With Address Skipped"
    description: "# sessions in which at least one Address Skipped event happened"
    type: count
    filters: [cnte_address_skipped: ">0"]
  }

  measure: cnt_map_viewed {
    group_label: "# Sessions"
    label: "# Sessions With Map Viewed"
    description: "# sessions in which at least one Map Viewed event happened"
    type: count
    filters: [cnte_map_viewed: ">0"]
  }

  ######## Count Events Within Session ########
  dimension: cnte_address_confirmed {
    group_label: "Count Events"
    label: "# Address Confirmed Events"
    description: "Number of Address Confirmed events within a single session. For example, the event might've occured twice for a certain session_id"
    type: number
    sql: ${TABLE}.cnt_address_confirmed ;;
  }

  dimension: cnte_address_resolution_failed_inside_area {
    group_label: "Count Events"
    label: "# Address Resolution Failed Events Inside Delivery Area"
    type: number
    description: "Number of addressResolutionFailed events inside delivery area if there are any, NULL otherwise"
    sql: ${TABLE}.cnt_address_resolution_failed_inside_area ;;
  }

  dimension: cnte_address_resolution_failed_outside_area {
    group_label: "Count Events"
    label: "# Address Resolution Failed Events Outside Delivery Area"
    type: number
    description: "Number of addressResolutionFailed events outside delivery area if there are any, NULL otherwise"
    sql: ${TABLE}.cnt_address_resolution_failed_outside_area ;;
  }

  dimension: cnte_address_skipped {
    group_label: "Count Events"
    label: "# Address Skipped Events"
    description: "Number of Address Skipped events within a single session. For example, the event might've occured twice for a certain session_id"
    type: number
    sql: ${TABLE}.cnt_address_skipped ;;
  }

  dimension: cnte_home_viewed {
    group_label: "Count Events"
    label: "# Home Viewed Events"
    description: "Number of Home Viewed events within a single session. For example, the event might've occured twice for a certain session_id"
    type: number
    sql: ${TABLE}.cnt_home_viewed ;;
  }

  dimension: cnte_location_pin_placed {
    group_label: "Count Events"
    label: "# Location Pin Placed Events"
    description: "Number of Location Pin Placed events within a single session. For example, the event might've occured twice for a certain session_id"
    type: number
    sql: ${TABLE}.cnt_location_pin_placed ;;
  }

  dimension: cnte_map_viewed {
    group_label: "Count Events"
    label: "# Map Viewed Events"
    description: "Number of Map viewed events within a single session. For example, the event might've occured twice for a certain session_id"
    type: number
    sql: ${TABLE}.cnt_map_viewed ;;
  }

  dimension: cnte_selection_browse_selected {
    group_label: "Count Events"
    label: "# Browse Selection Events"
    description: "Number of Product Browse events within a single session. For example, the event might've occured twice for a certain session_id"
    type: number
    sql: ${TABLE}.cnt_selection_browse_selected ;;
  }

  dimension: cnte_waitlist_signup_selected {
    group_label: "Count Events"
    label: "# Waitlist Signup Selected Events"
    description: "Number of Waitlist Signup Selected events within a single session. For example, the event might've occured twice for a certain session_id"
    type: number
    sql: ${TABLE}.cnt_waitlist_signup_selected ;;
  }

  ######## Session Attributes ########

  dimension: is_session_with_address {
    group_label: "Session Dimensions"
    description: "Whether the session had a deliverable Address Confirmed (either saved from a previous session or selected in the current one)"
    type: yesno
    sql: ${TABLE}.is_session_with_address ;;
  }

  dimension: is_new_user {
    group_label: "Session Dimensions"
    description: "Whether it was the first session of the user (= new user)"
    type: yesno
    sql: ${TABLE}.is_new_user ;;
  }

  dimension: hub_unknown {
    group_label: "Session Dimensions"
    label: "Has Unknown Hub"
    description: "Whether the session had no hub_code"
    type: yesno
    sql: ${hub_code} IS NULL ;;
  }

  dimension: has_address_confirmed_event {
    group_label: "Session Dimensions"
    description: "Whether there was an address selection event in the session"
    type: yesno
    sql: ${cnte_address_confirmed} >0 ;;
  }

  dimension: delivery_pdt {
    group_label: "Session Dimensions"
    label: "Delivery PDT"
    description: "The delivery PDT in minutes associated with the selected address"
    type: number
    sql: ${TABLE}.delivery_pdt ;;
  }

  dimension: delivery_lat {
    group_label: "Session Dimensions"
    label: "Delivery Latitude"
    description: "The latitude of the address to deliver to"
    type: number
    sql: ${TABLE}.delivery_lat ;;
  }

  dimension: delivery_lng {
    group_label: "Session Dimensions"
    label: "Delivery Longitude"
    description: "The longitude of the address to deliver to"
    type: number
    sql: ${TABLE}.delivery_lng ;;
  }

  dimension: last_is_inside_delivery_area {
    group_label: "Session Dimensions"
    label: "Is Inside Delivery Area"
    description: "FALSE if the last locationPinPlaced event in the session was not inside a delivery zone, TRUE if the last pin was inside, and NULL if there was no locationPinPlaced event"
    type: string
    # has null value if there was no location-related event in the session. yesno forces null to equal false, so need to get value as string
    sql: CAST(${TABLE}.last_is_inside_delivery_area AS STRING) ;;
  }

  dimension: last_is_location_deliverable {
    group_label: "Session Dimensions"
    label: "Is Location Deliverable"
    description: "FALSE if the last locationPinPlaced event in the session was not from a deliverable location, TRUE if the last pin was inside, and NULL if there was no locationPinPlaced event"
    type: string
    # has null value if there was no location-related event in the session. yesno forces null to equal false, so need to get value as string
    sql: CAST(${TABLE}.last_is_location_deliverable AS STRING) ;;
  }

  ######## Dates ########
  dimension_group: session {
    group_label: "Date Dimensions"
    label: "Session Date"
    type: time
    timeframes: [
      raw,
      date,
      week,
      month,
      quarter,
      year
    ]
    convert_tz: no
    datatype: date
    sql: ${TABLE}.session_date ;;
  }

  dimension: session_duration_minutes {
    type: number
    sql: ${TABLE}.session_duration_minutes ;;
  }

  dimension_group: session_start_at {
    # hidden because with session_start_date_granulairy and dynamic date, this field is duplicated
    group_label: "Date Dimensions"
    hidden: yes
    type: time
    timeframes: [
      raw,
      time,
      date,
      day_of_week,
      week,
      month,
      quarter,
      year
    ]
    sql: ${TABLE}.session_start_at ;;
  }

  dimension_group: session_end_at {
    # hidden because with dynamic date and session_end_date_granulairy, this field is duplicated
    group_label: "Date Dimensions"
    hidden: yes
    type: time
    timeframes: [
      raw,
      time,
      date,
      day_of_week,
      week,
      month,
      quarter,
      year
    ]
    sql: ${TABLE}.session_end_at ;;
  }

  dimension: session_start_date_granularity {
    group_label: "Date Dimensions"
    label: "Session Start Date (Dynamic)"
    label_from_parameter: timeframe_picker
    description: "Session Start Date. Note to set timeframe for week, month, etc., filter on Session Date Granularity Setting. This field will update accordingly"
    type: string # cannot have this as a time type. See this discussion: https://community.looker.com/lookml-5/dynamic-time-granularity-opinions-16675
    sql:
    {% if timeframe_picker._parameter_value == 'Day' %}
      ${session_start_at_date}
    {% elsif timeframe_picker._parameter_value == 'Week' %}
      ${session_start_at_week}
    {% elsif timeframe_picker._parameter_value == 'Month' %}
      ${session_start_at_month}
    {% elsif timeframe_picker._parameter_value == 'Quarter' %}
      ${session_start_at_quarter}
    {% elsif timeframe_picker._parameter_value == 'Year' %}
      ${session_start_at_year}
    {% elsif timeframe_picker._parameter_value == 'Day of Week' %}
      ${session_start_at_day_of_week}
    {% endif %};;
  }

  dimension: session_end_date_granularity {
    group_label: "Date Dimensions"
    label: "Session End Date (Dynamic)"
    label_from_parameter: timeframe_picker
    description: "Session End Date. Note to set timeframe for week, month, etc., filter on Session Date Granularity Setting. This field will update accordingly"
    type: string # cannot have this as a time type. See this discussion: https://community.looker.com/lookml-5/dynamic-time-granularity-opinions-16675
    sql:
    {% if timeframe_picker._parameter_value == 'Day' %}
      ${session_end_at_date}
    {% elsif timeframe_picker._parameter_value == 'Week' %}
      ${session_end_at_week}
    {% elsif timeframe_picker._parameter_value == 'Month' %}
      ${session_end_at_month}
    {% elsif timeframe_picker._parameter_value == 'Quarter' %}
      ${session_end_at_quarter}
    {% elsif timeframe_picker._parameter_value == 'Year' %}
      ${session_end_at_year}
    {% elsif timeframe_picker._parameter_value == 'Day of Week' %}
      ${session_end_at_day_of_week}
    {% endif %};;
  }

  parameter: timeframe_picker {
    label: "Session Date Granularity Setting"
    type: unquoted
    allowed_value: { value: "Day" }
    allowed_value: { value: "Week" }
    allowed_value: { value: "Month" }
    allowed_value: { value: "Quarter" }
    allowed_value: { value: "Year" }
    allowed_value: { value: "Day of Week" }
    default_value: "Day"
  }

  measure: mcvr1 {
    label: "mCVR1"
    type: number
    description: "Number of sessions in which an Addres Confirmed event happened, compared to the total number of Session Started"
    value_format_name: percent_1
    sql: ${cnt_address_selected}/NULLIF(${count},0) ;;
  }

  measure: cnt_unique_anonymousid {
    label: "# Users"
    description: "# unique users based on Anonymous ID from Segment"
    type: count_distinct
    sql: ${anonymous_id};;
    value_format_name: decimal_0
  }

  set: detail {
    fields: [
      cnte_location_pin_placed,
      last_is_inside_delivery_area,
      last_is_location_deliverable,
      cnte_address_skipped,
      cnte_address_resolution_failed_inside_area,
      cnte_address_resolution_failed_outside_area,
      cnte_address_confirmed,
      has_waitlist_signup_selected,
      anonymous_id,
      app_version,
      device_type,
      session_id,
      is_new_user,
      session_start_at_date,
      session_end_at_date,
      hub_code,
      country_iso,
      hub_city,
      delivery_pdt,
      is_session_with_address
    ]
  }
}
