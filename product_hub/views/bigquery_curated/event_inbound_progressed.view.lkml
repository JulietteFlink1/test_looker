view: event_inbound_progressed {
  sql_table_name: `flink-data-dev.curated.event_inbound_progressed`
    ;;

  dimension: action {
    type: string
    description: "The action performed. It can be item_picked, item_skipped, item_refunded or item_reset."
    sql: ${TABLE}.action ;;
  }

  dimension: anonymous_id {
    type: string
    description: "Unique ID for each user set by Segement."
    sql: ${TABLE}.anonymous_id ;;
  }

  dimension: context_ip {
    type: string
    sql: ${TABLE}.context_ip ;;
  }

  dimension: country_iso {
    type: string
    description: "Country ISO based on 'hub_code'."
    sql: ${TABLE}.country_iso ;;
  }

  dimension: dropping_list_id {
    type: string
    description: "Unique identifier generated by back-end when the inbound process is started (legacy inventory_movement_id)."
    sql: ${TABLE}.dropping_list_id ;;
  }

  dimension_group: event {
    type: time
    description: "Date when an event was triggered."
    timeframes: [
      raw,
      date,
      week,
      month,
      quarter,
      year
    ]
    convert_tz: no
    datatype: date
    sql: ${TABLE}.event_date ;;
  }

  dimension: event_name {
    type: string
    description: "Name of an event triggered."
    sql: ${TABLE}.event_name ;;
  }

  dimension_group: event_timestamp {
    type: time
    description: "Timestamp when an event was triggered within the app / web."
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year
    ]
    sql: ${TABLE}.event_timestamp ;;
  }

  dimension: event_uuid {
    type: string
    description: "Unique ID for each event defined by Segment."
    sql: ${TABLE}.event_uuid ;;
  }

  dimension: hub_code {
    type: string
    description: "Code of a hub identical to back-end source tables."
    sql: ${TABLE}.hub_code ;;
  }

  dimension: is_handling_unit {
    type: yesno
    description: "True when the action was perform at handling unit."
    sql: ${TABLE}.is_handling_unit ;;
  }

  dimension: locale {
    type: string
    sql: ${TABLE}.locale ;;
  }

  dimension: method {
    type: string
    description: "The used method to add/modify a product during list preparation. It can be scanned, text_searched, advanced_searched or manual (only for updated)."
    sql: ${TABLE}.method ;;
  }

  dimension_group: original_timestamp {
    type: time
    description: "Timestamp on the client device when call was invoked."
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year
    ]
    sql: ${TABLE}.original_timestamp ;;
  }

  dimension: page_path {
    type: string
    description: "Page path of users' page view. Page path does not contain domain information nor query parameters."
    sql: ${TABLE}.page_path ;;
  }

  dimension: page_title {
    type: string
    sql: ${TABLE}.page_title ;;
  }

  dimension: page_url {
    type: string
    sql: ${TABLE}.page_url ;;
  }

  dimension: product_sku {
    type: string
    description: "SKU of the product, as available in the backend."
    sql: ${TABLE}.product_sku ;;
  }

  dimension: quantity {
    type: number
    description: "The quantity affected. It is always in single units and can be negative when action = product_updated_quantity."
    sql: ${TABLE}.quantity ;;
  }

  dimension: quinyx_badge_number {
    type: string
    description: "Employment ID that was initially generated by bambooHR. It is used to identify staff members from hub operations. To be able to map employees between different HR systems (after migrating to SAP), we still refered to it as quiniyx badge number. Quiniyx is used as our workforce management tool for rider ops."
    sql: ${TABLE}.quinyx_badge_number ;;
  }

  dimension_group: received {
    type: time
    description: "Timestamp when an event was received on the server, used for data laod."
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year
    ]
    sql: ${TABLE}.received_at ;;
  }

  dimension: screen_name {
    type: string
    description: "Name of the screen where the event occurs, in human readable form. This should be consistent for all events fired on the same screen."
    sql: ${TABLE}.screen_name ;;
  }

  dimension: user_agent {
    type: string
    sql: ${TABLE}.user_agent ;;
  }

  dimension: user_id {
    type: string
    description: "Should be populated with Auth0Id, but as of now we are receiving null in this field and using quynix_badge_number to identify users/ employees in the hubs."
    sql: ${TABLE}.user_id ;;
  }

  measure: count {
    type: count
    drill_fields: [screen_name, event_name]
  }
}
